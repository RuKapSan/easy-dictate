name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  # Run E2E tests first to ensure quality
  test:
    name: Run E2E Tests
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Cache Cargo binaries
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/
          key: ${{ runner.os }}-cargo-bins-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-bins-

      - name: Cache E2E node_modules
        uses: actions/cache@v4
        with:
          path: tests/e2e/node_modules
          key: ${{ runner.os }}-e2e-node-${{ hashFiles('tests/e2e/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-e2e-node-

      - name: Install E2E test dependencies
        working-directory: tests/e2e
        run: npm ci

      - name: Install Tauri CLI
        shell: bash
        run: |
          if ! command -v cargo-tauri &> /dev/null; then
            cargo install tauri-cli --locked
          else
            echo "tauri-cli already installed"
          fi

      - name: Install tauri-driver
        shell: bash
        run: |
          if ! command -v tauri-driver &> /dev/null; then
            cargo install tauri-driver --locked
          else
            echo "tauri-driver already installed"
          fi

      - name: Install matching msedgedriver
        shell: pwsh
        run: |
          $edgePath = "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
          $edgeVersion = (Get-Item $edgePath).VersionInfo.FileVersion
          Write-Host "Edge version: $edgeVersion"
          # Find and replace ALL existing msedgedriver.exe on the system
          $existing = Get-Command msedgedriver -ErrorAction SilentlyContinue
          if ($existing) { Write-Host "Existing msedgedriver at: $($existing.Source)" }
          $url = "https://msedgedriver.microsoft.com/$edgeVersion/edgedriver_win64.zip"
          Write-Host "Downloading msedgedriver from: $url"
          Invoke-WebRequest -Uri $url -OutFile "$env:TEMP\edgedriver.zip"
          Expand-Archive -Path "$env:TEMP\edgedriver.zip" -DestinationPath "$env:TEMP\edgedriver" -Force
          # Replace the system-cached msedgedriver
          Get-ChildItem -Path "C:\SeleniumWebDrivers" -Recurse -Filter "msedgedriver.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Replacing: $($_.FullName)"
            Copy-Item "$env:TEMP\edgedriver\msedgedriver.exe" -Destination $_.FullName -Force
          }
          # Also place in a high-priority PATH location
          Copy-Item "$env:TEMP\edgedriver\msedgedriver.exe" -Destination "C:\Windows\msedgedriver.exe" -Force
          msedgedriver --version

      - name: Build Tauri app (debug, for test commands)
        working-directory: src-tauri
        run: cargo tauri build --debug

      - name: Run E2E tests
        working-directory: tests/e2e
        run: npm test
        env:
          CI: true

      - name: Upload E2E artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-failures
          path: |
            tests/e2e/screenshots/
            tests/e2e/videos/
            tests/e2e/logs/
          retention-days: 7

  # Build for all platforms
  build:
    name: Build ${{ matrix.platform.target }}
    needs: test
    strategy:
      fail-fast: false
      matrix:
        platform:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            artifacts: |
              src-tauri/target/x86_64-pc-windows-msvc/release/bundle/msi/*.msi
              src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis/*.exe

          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifacts: |
              src-tauri/target/x86_64-unknown-linux-gnu/release/bundle/deb/*.deb
              src-tauri/target/x86_64-unknown-linux-gnu/release/bundle/appimage/*.AppImage

          - os: macos-latest
            target: x86_64-apple-darwin
            artifacts: |
              src-tauri/target/x86_64-apple-darwin/release/bundle/dmg/*.dmg

          - os: macos-latest
            target: aarch64-apple-darwin
            artifacts: |
              src-tauri/target/aarch64-apple-darwin/release/bundle/dmg/*.dmg

    runs-on: ${{ matrix.platform.os }}
    timeout-minutes: 60

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform.target }}

      - name: Install Linux dependencies
        if: matrix.platform.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libasound2-dev libsecret-1-dev

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          key: ${{ matrix.platform.target }}

      - name: Cache Cargo binaries
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/
          key: ${{ runner.os }}-cargo-bins-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-bins-

      - name: Install Tauri CLI
        shell: bash
        run: |
          if ! command -v cargo-tauri &> /dev/null; then
            cargo install tauri-cli --locked
          else
            echo "tauri-cli already installed"
          fi

      - name: Build Tauri app for ${{ matrix.platform.target }}
        working-directory: src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: cargo tauri build --target ${{ matrix.platform.target }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.platform.target }}
          path: |
            ${{ matrix.platform.artifacts }}
            src-tauri/target/${{ matrix.platform.target }}/release/bundle/**/*.sig
          retention-days: 7

  # Create GitHub Release
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Display artifact structure
        run: |
          echo "=== Checking artifacts directory ==="
          if [ -d "artifacts" ]; then
            ls -R artifacts/
          else
            echo "No artifacts directory found"
            echo "Available files:"
            ls -la
          fi

      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          echo "## Changes" > CHANGELOG.md
          git log $(git describe --tags --abbrev=0 HEAD^)..HEAD --pretty=format:"- %s (%h)" >> CHANGELOG.md
          cat CHANGELOG.md

      - name: Generate updater manifest
        id: manifest
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Find the actual installer files (search recursively in artifacts)
          WIN_MSI=$(find artifacts -name "*.msi" ! -name "*.sig" | head -1)
          WIN_EXE=$(find artifacts -name "*-setup.exe" ! -name "*.sig" | head -1)
          LINUX_APPIMAGE=$(find artifacts -name "*.AppImage" ! -name "*.sig" | head -1)
          MAC_INTEL_DMG=$(find artifacts/release-x86_64-apple-darwin -name "*.dmg" ! -name "*.sig" 2>/dev/null | head -1)
          MAC_ARM_DMG=$(find artifacts/release-aarch64-apple-darwin -name "*.dmg" ! -name "*.sig" 2>/dev/null | head -1)

          # Read signatures from .sig files (generated by Tauri when TAURI_SIGNING_PRIVATE_KEY is set)
          read_sig() {
            local installer="$1"
            local sig_file="${installer}.sig"
            if [ -f "$sig_file" ]; then
              cat "$sig_file"
            else
              # Try finding .sig in the same artifact directory
              local base=$(basename "$installer")
              local found=$(find artifacts -name "${base}.sig" | head -1)
              if [ -n "$found" ]; then
                cat "$found"
              else
                echo ""
              fi
            fi
          }

          WIN_MSI_SIG=$(read_sig "$WIN_MSI")
          LINUX_APPIMAGE_SIG=$(read_sig "$LINUX_APPIMAGE")
          MAC_INTEL_DMG_SIG=$(read_sig "$MAC_INTEL_DMG")
          MAC_ARM_DMG_SIG=$(read_sig "$MAC_ARM_DMG")

          # Get base names for URLs
          WIN_MSI_NAME=$(basename "$WIN_MSI")
          LINUX_APPIMAGE_NAME=$(basename "$LINUX_APPIMAGE")
          MAC_INTEL_DMG_NAME=$(basename "$MAC_INTEL_DMG")
          MAC_ARM_DMG_NAME=$(basename "$MAC_ARM_DMG")

          # Generate latest.json for Tauri updater
          cat > latest.json << EOF
          {
            "version": "$VERSION",
            "date": "$DATE",
            "platforms": {
              "windows-x86_64": {
                "signature": "$WIN_MSI_SIG",
                "url": "https://github.com/RuKapSan/easy-dictate/releases/download/v${VERSION}/${WIN_MSI_NAME}"
              },
              "linux-x86_64": {
                "signature": "$LINUX_APPIMAGE_SIG",
                "url": "https://github.com/RuKapSan/easy-dictate/releases/download/v${VERSION}/${LINUX_APPIMAGE_NAME}"
              },
              "darwin-x86_64": {
                "signature": "$MAC_INTEL_DMG_SIG",
                "url": "https://github.com/RuKapSan/easy-dictate/releases/download/v${VERSION}/${MAC_INTEL_DMG_NAME}"
              },
              "darwin-aarch64": {
                "signature": "$MAC_ARM_DMG_SIG",
                "url": "https://github.com/RuKapSan/easy-dictate/releases/download/v${VERSION}/${MAC_ARM_DMG_NAME}"
              }
            }
          }
          EOF

          cat latest.json
          echo "Updater manifest generated"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ github.ref_name }}"

          # Find all installer files and handle spaces in filenames.
          mapfile -d '' -t INSTALLERS < <(find artifacts -type f \( -name "*.msi" -o -name "*.exe" -o -name "*.deb" -o -name "*.AppImage" -o -name "*.dmg" \) -print0)
          echo "Found installers:"
          for file in "${INSTALLERS[@]}"; do
            echo "$file"
          done

          if [ "${#INSTALLERS[@]}" -eq 0 ]; then
            echo "::error::No installer files found in artifacts/"
            exit 1
          fi

          # Create release only if it does not exist, so reruns don't fail.
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists, updating assets"
          else
            gh release create "$TAG" \
              --title "Easy Dictate v${{ steps.version.outputs.version }}" \
              --notes-file CHANGELOG.md
          fi

          # Upload manifest and installers. --clobber makes reruns safe.
          gh release upload "$TAG" latest.json --clobber
          for file in "${INSTALLERS[@]}"; do
            echo "Uploading: $file"
            gh release upload "$TAG" "$file" --clobber
          done
